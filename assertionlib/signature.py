"""
assertionlib.signature
======================

Various functions for manipulating function signatures.

Index
-----
.. currentmodule:: assertionlib.signature
.. autosummary::
    generate_signature
    BACK_SIGNATURE
    _get_backup_signature
    _signature_to_str

API
---
.. autofunction:: generate_signature
.. autodata:: BACK_SIGNATURE
.. autofunction:: _get_backup_signature
.. autofunction:: _signature_to_str

"""

from typing import Callable, Optional, Type, Dict
from inspect import Parameter, Signature, signature, _empty, _ParameterKind

PO: _ParameterKind = Parameter.POSITIONAL_ONLY
POK: _ParameterKind = Parameter.POSITIONAL_OR_KEYWORD
VP: _ParameterKind = Parameter.VAR_POSITIONAL
KO: _ParameterKind = Parameter.KEYWORD_ONLY
VK: _ParameterKind = Parameter.VAR_KEYWORD

#: Annotation for (optional) exception types
ExType = Optional[Type[Exception]]


def _get_backup_signature() -> Signature:
    """Create a generic backup :class:`Signature<inspect.Signature>` instance.

    Used in :func:`generate_signature` incase a callables' signature cannot be read.

    Returns
    -------
    :class:`Signature<inspect.Signature>`
        ``<Signature (self, *args, invert_: bool = False, exception_: Union[Type[Exception], NoneType] = None, **kwargs) -> None>``

    See Also
    --------
    :attr:`Parameter.kind<inspect.Parameter.kind>`
        Describes how argument values are bound to the parameter.

    :data:`.BACK_SIGNATURE`
        A generic backup signature generated by this function.

    """  # noqa
    parameters = [
        Parameter(name='self', kind=POK),  # Avoid using positional-only
        Parameter(name='args', kind=VP),
        Parameter(name='invert', kind=KO, default=False, annotation=bool),
        Parameter(name='exception', kind=KO, default=None, annotation=ExType),
        Parameter(name='kwargs', kind=VK)
    ]
    return Signature(parameters=parameters, return_annotation=None)


#: A generic backup :class:`Signature<inspect.Signature>` generated
#: by :func:`._get_backup_signature`.
BACK_SIGNATURE: Signature = _get_backup_signature()


def generate_signature(func: Callable) -> Signature:
    """Generate a new function signatures with the ``self``, ``invert`` and ``exception`` parameters.

    Default to :data:`BACK_SIGNATURE` if a functions' signature cannot be read.

    Examples
    --------
    .. code:: python

        >>> import inspect

        >>> func = enumerate  # The builtin enumerate function
        >>> Signature = inspect.Signature

        # Print the signature of enumerate
        >>> sgn1: Signature = inspect.signature(func)
        >>> print(sgn1)
        (iterable, start=0)

        # Print the newly create signature
        >>> sgn2: Signature = generate_signatures(func)
        >>> print(sgn2)
        (self, iterable, *args, start=0, invert_: bool = False, exception_: Union[Type[Exception], NoneType] = None, **kwargs) -> None

    Parameters
    ----------
    func : :data:`Callable<typing.Callable>`
        A callable object.

    Returns
    -------
    :class:`Signature<inspect.Signature>`
        The signature of **func** with the ``self`` and ``invert`` parameters.
        Return :data:`.BACK_SIGNATURE` if funcs' signature cannot be read.

    """  # noqa
    try:
        sgn = signature(func)
    except ValueError:  # Not all callables have a signature that can be read.
        return BACK_SIGNATURE

    has_VP = False  # Does the signature contain an *args-like argument?
    has_VK = False  # Does the signature contain a **kwargs-like argument?

    parameters = [Parameter(name='self', kind=POK)]
    for name, prm in sgn.parameters.items():
        if prm.kind is VP:
            has_VP = True
            parameters.append(Parameter(name=prm.name, kind=VP, default=prm.default, annotation=prm.annotation))  # noqa
            continue
        elif not has_VP and prm.default is not _empty:
            parameters.append(Parameter(name='args', kind=VP))
            has_VP = True
        elif prm.kind is VK:  # Add the `invert` argument before a **kwargs-like argument
            parameters.append(Parameter(name='invert', kind=KO, default=False, annotation=bool))
            parameters.append(Parameter(name='exception', kind=KO, default=None, annotation=ExType))
            parameters.append(Parameter(name=prm.name, kind=VK, default=prm.default, annotation=prm.annotation))  # noqa
            has_VK = True
            break

        if has_VP:  # Convert positional-only to positional or keyword
            prm = Parameter(name=prm.name, kind=KO, default=prm.default, annotation=prm.annotation)
        elif prm.kind is PO:  # Convert positional-only to positional or keyword
            prm = Parameter(name=prm.name, kind=POK, default=prm.default, annotation=prm.annotation)
        parameters.append(prm)

    # The signature does not contain a **kwargs-like argument; the invert parameter has not been set
    if not has_VP:
        parameters.append(Parameter(name='args', kind=VP))
    if not has_VK:
        parameters.append(Parameter(name='invert', kind=KO, default=False, annotation=bool))
        parameters.append(Parameter(name='exception', kind=KO, default=None, annotation=ExType))
        parameters.append(Parameter(name='kwargs', kind=VK))

    # print(repr([p.kind for p in parameters]))
    return Signature(parameters=parameters, return_annotation=None)


#: A dictionary for creating format string for specific parameter kinds.
#: Used by :func:`_signature_to_str`.
_KIND_TO_STR: Dict[_ParameterKind, str] = {
    PO: '{}',
    POK: '{}',
    VP: '*{}',
    VK: '**{}',
}


def _signature_to_str(sgn: Signature, func_name: Optional[str] = None) -> str:
    """Create a string from a signature.

    * The ``self`` parameter will be substituted for **func_name**,
      *i.e.* the name of the to-be asserted function.
    * Annotations will be removed
    * keyword arguments will have their default values replaced with their respective keys.

    Examples
    --------
    .. code:: python

        >>> import inspect

        >>> Signature = inspect.Signature

        >>> def func(self, a: int, b: float, *args, c=1, d=2, **kwargs) -> None:
        ...     pass

        >>> sgn: Signature = inspect.signature(func)
        >>> print(sgn)
        (self, a: int, b: float, *args, c=1, d=2, **kwargs) -> None

        >>> sgn_str: str = _signature_to_str(sgn, func_name='fancy_func_name')
        >>> print(sgn_str)
        (fancy_func_name, a, b, *args, c=c, d=d, **kwargs)

    Parameters
    ----------
    sgn : :class:`Signature<inspect.Signature>`
        A Signature object.

    func_name : :class:`str`, optional
        If not ``None``, replace all references to ``self`` with **func_name**.

    Returns
    -------
    :class:`str`
        A stringified version of **sgn**.

    """
    func_name = 'self' if func_name is None else func_name
    parameters = []
    for name, prm in sgn.parameters.items():
        if name == 'self':
            value = func_name
        elif prm.default is not _empty:
            value = f'{name}={name}'
        else:
            value = _KIND_TO_STR[prm.kind].format(name)
        parameters.append(value)

    return '(' + ', '.join(i for i in parameters) + ')'
